// Generated by CoffeeScript 1.6.1
(function() {
  var make_autocomplete, make_form, make_form_events, _dirty, _disabled, _invisible, _make_autorun, _obj_from_path, _on_change, _on_change_bool, _on_change_generic, _str_xsplit,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _on_change_generic = function(form_name, klass) {
    return function(e, t) {
      var name, value;
      name = $(e.target).attr('name');
      value = $(e.target).val();
      return _on_change(form_name, klass, name, value);
    };
  };

  _on_change_bool = function(form_name, klass) {
    return function(e, t) {
      var name, value;
      name = $(e.target).attr('name');
      value = $(e.target).is(':checked');
      return _on_change(form_name, klass, name, value);
    };
  };

  _on_change = function(form_name, klass, name, value) {
    var func, obj, _i, _len, _ref;
    obj = Session.get(form_name + '_object');
    if (__indexOf.call(obj._dirty, name) < 0) {
      obj._dirty.push(name);
    }
    try {
      value = klass[name][0](value);
      _ref = klass[name].slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        func = _ref[_i];
        func(value);
      }
      obj['_error_' + name] = '';
    } catch (error) {
      obj['_error_' + name] = error;
    }
    if (moment.isMoment(value)) {
      value = value.toDate();
    }
    obj[name] = value;
    return Session.set(form_name + '_object', obj);
  };

  make_form_events = function(form_name, klass) {
    var dct;
    dct = {};
    dct['mouseup #' + form_name + '_save'] = function(e, t) {
      var obj;
      obj = Session.get(form_name + '_object');
      return klass.save(obj, form_name);
    };
    dct['input .' + form_name + '_attr'] = _on_change_generic(form_name, klass);
    dct['change .' + form_name + '_attr_bool'] = _on_change_bool(form_name, klass);
    dct['change .' + form_name + '_attr_select'] = _on_change_generic(form_name, klass);
    return dct;
  };

  _obj_from_path = function(obj, path) {
    var id, v, _i, _len;
    id = obj._id;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      v = path[_i];
      obj = obj[v];
    }
    if (!obj) {
      obj = {};
    }
    obj._id = id;
    return obj;
  };

  _str_xsplit = function(txt) {
    var id_path, json_exp;
    json_exp = _.strRight(txt, '.{');
    if (json_exp === txt) {
      id_path = txt;
      json_exp = "";
    } else {
      json_exp = "{" + json_exp;
      id_path = _.strLeft(txt, '.{');
    }
    return [id_path, json_exp];
  };

  _make_autorun = function(form_name, klass, parent) {
    return function() {
      var id, initial, initials, jex, obj, path, _ref, _ref1, _ref2;
      if (parent !== null) {
        _ref = _str_xsplit(Session.get(parent + '_object_id')), id = _ref[0], jex = _ref[1];
        _ref1 = _str_xsplit(Session.get(form_name + '_object_id')), path = _ref1[0], initial = _ref1[1];
        path = path.split('.');
      } else {
        _ref2 = _str_xsplit(Session.get(form_name + '_object_id')), id = _ref2[0], initial = _ref2[1];
        path = [];
      }
      Meteor.subscribe(form_name + "_x_id", id);
      obj = klass._collection.findOne({
        _id: id
      });
      if (path.length === 0) {
        if (obj) {
          obj._path = [];
          return Session.set(form_name + '_object', klass.constructor(obj));
        } else {
          return Session.set(form_name + '_object', klass.constructor({
            _id: '',
            _path: []
          }, initials = initial));
        }
      } else {
        if (obj) {
          obj = _obj_from_path(obj, path);
          obj._path = path;
          return Session.set(form_name + '_object', klass.constructor(obj));
        } else {
          return Session.set(form_name + '_object', klass.constructor({
            _id: ''
          }, initials = initial));
        }
      }
    };
  };

  _dirty = function(form_name) {
    return function(attr) {
      var obj;
      obj = Session.get(form_name + '_object');
      if (__indexOf.call(obj._dirty, attr) >= 0) {
        return 'dirty';
      } else {
        return '';
      }
    };
  };

  _invisible = function(parent) {
    return function() {
      if (Session.get(parent + '_object_id') === '') {
        return "invisible";
      } else {
        return "";
      }
    };
  };

  _disabled = function(form_name, klass) {
    return function() {
      var attr, obj, _i, _len, _ref;
      obj = Session.get(form_name + '_object');
      _ref = klass._attrs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        if (obj['_error_' + attr] !== '') {
          return 'disabled';
        }
      }
      if (obj._dirty.length === 0) {
        return 'disabled';
      }
      return '';
    };
  };

  make_form = function(template, form_name, klass, for_rendered, parent, path) {
    if (for_rendered == null) {
      for_rendered = null;
    }
    if (parent == null) {
      parent = null;
    }
    if (path == null) {
      path = null;
    }
    if (!path) {
      Session.set(form_name + '_object_id', '');
    } else {
      Meteor.autorun(function() {
        Session.get(parent + '_object_id');
        return Session.set(form_name + '_object_id', path);
      });
    }
    Meteor.autorun(_make_autorun(form_name, klass, parent));
    template.objeto = function() {
      return Session.get(form_name + '_object');
    };
    template.dirty = _dirty(form_name);
    if (parent) {
      template.invisible = _invisible(parent);
    }
    template.format_string_array = function(list) {
      if (list) {
        return list.join('\n');
      }
    };
    template.selected = function(option, value) {
      if (option === value) {
        return 'selected';
      } else {
        return '';
      }
    };
    template.disabled = _disabled(form_name, klass);
    template.events(make_form_events(form_name, klass));
    template.from_pk = function(data_id, lista, attr) {
      var obj;
      lista = window[lista];
      obj = lista.findOne({
        _id: data_id
      });
      if (obj) {
        return obj[attr];
      }
    };
    template.format_datetime = function(format, fecha) {
      if (fecha) {
        fecha = moment(fecha);
        return fecha.format(format);
      }
    };
    template.format_date = function(format, fecha) {
      if (fecha) {
        fecha = moment(fecha);
        return fecha.format(format);
      }
    };
    template.is_checked = function(value) {
      if (value) {
        return 'checked';
      } else {
        return '';
      }
    };
    return template.rendered = function() {
      var ac, attr, channel, collection, d, dt, _ref, _results;
      for (d in for_rendered['date']) {
        $(d).datepicker({
          format: for_rendered['date'][d],
          autoclose: true
        });
      }
      $('.' + form_name + '_attr_date').on('changeDate', _on_change_generic(form_name, klass));
      for (dt in for_rendered['datetime']) {
        $(dt).datetimepicker({
          format: for_rendered['datetime'][dt],
          autoclose: true
        });
      }
      $('.' + form_name + '_attr_datetime').on('changeDate', _on_change_generic(form_name, klass));
      $('.' + form_name + '_attr_autocomplete').on('change', _on_change_generic(form_name, klass));
      $('.' + form_name + '_attr_autocomplete').on('input', _on_change_generic(form_name, klass));
      _results = [];
      for (ac in for_rendered['autocomplete']) {
        _ref = for_rendered['autocomplete'][ac], channel = _ref[0], attr = _ref[1], collection = _ref[2];
        Meteor.subscribe(channel);
        _results.push(make_autocomplete(ac, attr, collection));
      }
      return _results;
    };
  };

  make_autocomplete = function(target_id, attr, collection) {
    return $(target_id).typeahead({
      source: function(q, p) {
        var c, dct, ret;
        dct = {};
        dct[attr] = {
          $regex: ".*" + q + ".*"
        };
        c = collection.find(dct);
        ret = [];
        c.forEach(function(race) {
          return ret.push(race[attr]);
        });
        p(ret);
        return ret;
      }
    });
  };

  this.model2rform_make_form = {
    make_form: make_form
  };

  if (typeof exports !== 'undefined') {
    exports.make_form = {
      _obj_from_path: _obj_from_path,
      _make_autorun: _make_autorun,
      _dirty: _dirty,
      _invisible: _invisible,
      _disabled: _disabled
    };
  }

}).call(this);
