// Generated by CoffeeScript 1.6.1
(function() {
  var checked, form_get, form_set, indeterminate, make_autocomplete, make_form, make_form_events, obj_from_path, rotate_checkbox, unchecked, _dirty, _disabled, _invisible, _make_autorun, _on_change, _on_change_bool, _on_change_generic,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  checked = "x";

  unchecked = " ";

  indeterminate = "--";

  _on_change_generic = function(form_name, klass) {
    return function(e, t) {
      var name, value;
      name = $(e.target).attr('name');
      value = $(e.target).val();
      return _on_change(form_name, klass, name, value);
    };
  };

  _on_change_bool = function(form_name, klass) {
    return function(e, t) {
      var name, value;
      value = rotate_checkbox(e.target);
      name = $(e.target).attr('name');
      return _on_change(form_name, klass, name, value);
    };
  };

  _on_change = function(form_name, klass, name, value) {
    var func, obj, _i, _len, _ref;
    obj = Session.get(form_name + '_object');
    console.log('name, value', name, value);
    if (__indexOf.call(obj._dirty, name) < 0) {
      obj._dirty.push(name);
    }
    try {
      value = klass[name][0](value);
      _ref = klass[name].slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        func = _ref[_i];
        func(value);
      }
      obj['_error_' + name] = '';
    } catch (error) {
      obj['_error_' + name] = error;
    }
    if (moment.isMoment(value)) {
      value = value.toDate();
    }
    obj[name] = value;
    return Session.set(form_name + '_object', obj);
  };

  rotate_checkbox = function(cb) {
    var data, el;
    el = $(cb);
    data = el.text();
    switch (data) {
      case indeterminate:
        return false;
      case unchecked:
        return true;
      default:
        return null;
    }
  };

  make_form_events = function(form_name, klass, initials) {
    var dct;
    dct = {};
    dct['mouseup #' + form_name + '_save'] = function(e, t) {
      var obj;
      obj = Session.get(form_name + '_object');
      return klass.save(obj, form_name);
    };
    dct['click #' + form_name + '_new'] = function(e, t) {
      var attr, channel, collection, x, _ref;
      _ref = JSON.parse(initials), channel = _ref[0], attr = _ref[1], collection = _ref[2];
      dct = {};
      dct[attr] = $('#' + form_name + '__initials').val();
      x = window[collection].findOne(dct);
      if (x) {
        delete x[attr];
        delete x._id;
        return form_set(form_name, x);
      }
    };
    dct['input .' + form_name + '_attr'] = _on_change_generic(form_name, klass);
    dct['click .' + form_name + '_attr_bool'] = _on_change_bool(form_name, klass);
    dct['change .' + form_name + '_attr_select'] = _on_change_generic(form_name, klass);
    return dct;
  };

  obj_from_path = function(obj, path) {
    var id, v, _i, _len;
    if (typeof path === 'string') {
      path = path.split('.');
    }
    id = obj._id;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      v = path[_i];
      obj = obj[v];
      if (obj === void 0) {
        break;
      }
    }
    if (!obj) {
      obj = {};
    }
    obj._id = id;
    obj._path = path;
    return obj;
  };

  form_get = function(form_name) {
    return Session.get(form_name + '_object');
  };

  form_set = function(form_name, obj_path) {
    return Session.set(form_name + '_object_id', obj_path);
  };

  _make_autorun = function(form_name, klass, parent, path) {
    return function() {
      var id, initial, initials, obj, path_, x;
      if (parent !== null) {
        x = Session.get(parent + '_object_id');
        if (typeof x === 'string') {
          id = x;
        } else {
          id = '';
        }
        path_ = path.split('.');
        initial = Session.get(form_name + '_object_id');
        if (typeof initial === 'string') {
          path_ = initial.split('.');
          initial = {};
        } else {
          if (initial && _.has(initial, '_path')) {
            path_ = initial._path.split('.');
            delete initial._path;
          }
        }
      } else {
        x = Session.get(form_name + '_object_id');
        if (typeof x === 'string') {
          id = x;
        } else {
          id = '';
          initial = x;
        }
        path_ = [];
      }
      if (id === '') {
        obj = null;
      } else {
        Meteor.subscribe(form_name + "_x_id", id);
        obj = klass._collection.findOne({
          _id: id
        });
      }
      if (path_.length === 0) {
        if (obj) {
          return Session.set(form_name + '_object', klass.constructor(obj));
        } else {
          return Session.set(form_name + '_object', klass.constructor({
            _id: '',
            _path: []
          }, initials = initial));
        }
      } else {
        if (obj) {
          obj = obj_from_path(obj, path_);
          if (_.isEqual(obj, {
            _id: obj._id,
            _path: path_
          })) {
            return Session.set(form_name + '_object', klass.constructor(obj, initials = initial));
          } else {
            return Session.set(form_name + '_object', klass.constructor(obj));
          }
        } else {
          return Session.set(form_name + '_object', klass.constructor({
            _id: ''
          }, initials = initial));
        }
      }
    };
  };

  _dirty = function(form_name) {
    return function(attr) {
      var obj;
      obj = Session.get(form_name + '_object');
      if (__indexOf.call(obj._dirty, attr) >= 0) {
        return 'dirty';
      } else {
        return '';
      }
    };
  };

  _invisible = function(parent, form_name) {
    return function() {
      var obj, v, x, _i, _len, _ref;
      if (_.isObject(Session.get(parent + '_object_id'))) {
        return "invisible";
      } else {
        obj = Session.get(form_name + '_object');
        x = Session.get(parent + '_object');
        _ref = obj._path.slice(0, -1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          x = x[v];
          if (x === void 0) {
            return "invisible";
          }
        }
        return "";
      }
    };
  };

  _disabled = function(form_name, klass) {
    return function() {
      var attr, obj, _i, _len, _ref;
      obj = Session.get(form_name + '_object');
      _ref = klass._attrs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        if (obj['_error_' + attr] !== '') {
          return 'disabled';
        }
      }
      if (_.isEqual(obj._dirty, ['_valid'])) {
        return 'disabled';
      }
      return '';
    };
  };

  make_form = function(template, form_name, klass, parent, path) {
    var yet_rendered;
    if (parent == null) {
      parent = null;
    }
    if (path == null) {
      path = null;
    }
    if (!path) {
      Session.set(form_name + '_object_id', {});
    }
    Meteor.autorun(_make_autorun(form_name, klass, parent, path));
    template.objeto = function() {
      return Session.get(form_name + '_object');
    };
    template.dirty = _dirty(form_name);
    if (parent) {
      template.invisible = _invisible(parent, form_name);
    }
    template.format_string_array = function(list) {
      if (list) {
        return list.join('\n');
      }
    };
    template.selected = function(option, value) {
      if (option === value) {
        return 'selected';
      } else {
        return '';
      }
    };
    template.map_null = function(value) {
      if (value === null) {
        return '';
      } else {
        return value;
      }
    };
    template.disabled = _disabled(form_name, klass);
    template.events(make_form_events(form_name, klass, klass._for_rendered['autocomplete']['_initials']));
    template.from_pk = function(data_id, lista, attr) {
      var obj;
      lista = window[lista];
      obj = lista.findOne({
        _id: data_id
      });
      if (obj) {
        return obj[attr];
      }
    };
    template.format_datetime = function(format, fecha) {
      if (fecha) {
        fecha = moment(fecha);
        return fecha.format(format);
      }
    };
    template.format_date = function(format, fecha) {
      if (fecha) {
        fecha = moment(fecha);
        return fecha.format(format);
      }
    };
    template.checked = function(value) {
      if (value === null || value === void 0) {
        return indeterminate;
      }
      if (value) {
        return checked;
      } else {
        return unchecked;
      }
    };
    yet_rendered = false;
    return template.rendered = function() {
      var ac, attr, channel, collection, d, d_, dt, dt_, for_rendered, selector, target_id, _ref, _results;
      if (!yet_rendered) {
        yet_rendered = true;
        for_rendered = klass._for_rendered;
        for (d in for_rendered['date']) {
          d_ = '#' + form_name + ' input[name=' + d + ']';
          $(d_).datepicker({
            format: for_rendered['date'][d],
            autoclose: true
          });
        }
        selector = '.' + form_name + '_attr_date';
        $(selector).on('changeDate', _on_change_generic(form_name, klass));
        for (dt in for_rendered['datetime']) {
          dt_ = '#' + form_name + ' input[name="' + dt + '"]';
          $(dt_).datetimepicker({
            format: for_rendered['datetime'][dt],
            autoclose: true
          });
        }
        selector = '.' + form_name + '_attr_datetime';
        $(selector).on('changeDate', _on_change_generic(form_name, klass));
        selector = '.' + form_name + '_attr_autocomplete';
        $(selector).on('change', _on_change_generic(form_name, klass));
        $(selector).on('input', _on_change_generic(form_name, klass));
        _results = [];
        for (ac in for_rendered['autocomplete']) {
          _ref = JSON.parse(for_rendered['autocomplete'][ac]), channel = _ref[0], attr = _ref[1], collection = _ref[2];
          Meteor.subscribe(channel);
          target_id = '#' + form_name + ' input[name=' + ac + ']';
          console.log(':', collection);
          _results.push(make_autocomplete(target_id, attr, window[collection]));
        }
        return _results;
      }
    };
  };

  make_autocomplete = function(target, attr, collection) {
    return $(target).typeahead({
      source: function(q, p) {
        var c, dct, ret;
        dct = {};
        dct[attr] = {
          $regex: ".*" + q + ".*"
        };
        c = collection.find(dct);
        ret = [];
        c.forEach(function(race) {
          return ret.push(race[attr]);
        });
        p(ret);
        return ret;
      }
    });
  };

  this.model2rform_make_form = {
    make_form: make_form,
    obj_from_path: obj_from_path,
    form_get: form_get,
    form_set: form_set
  };

  if (typeof exports !== 'undefined') {
    exports.make_form = {
      obj_from_path: obj_from_path,
      _make_autorun: _make_autorun,
      _dirty: _dirty,
      _invisible: _invisible,
      _disabled: _disabled
    };
  }

}).call(this);
