// Generated by CoffeeScript 1.6.1
(function() {
  var boolean, date, datetime, email, float, integer, max, min, nested, nested_array, references, required, smax, smin, string, string_array, string_select, text,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  boolean = function(x) {
    return x;
  };

  string = function(x) {
    return x;
  };

  text = function(x) {
    return x;
  };

  nested = function(klass) {
    return {
      klass: klass
    };
  };

  nested_array = function(klass) {
    return {
      klass: klass
    };
  };

  string_array = function(txt) {
    var v, _i, _len;
    if (typeof txt === 'string') {
      return txt.split('\n');
    }
    if (_.isArray(txt)) {
      for (_i = 0, _len = txt.length; _i < _len; _i++) {
        v = txt[_i];
        if (!typeof v === 'string') {
          throw "The array must be of strings.";
        }
      }
      return txt;
    }
    throw 'string_array error';
  };

  date = function(format) {
    return function(x) {
      if (x instanceof Date) {
        return moment(x);
      } else {
        if (!_.isString(x)) {
          throw 'Date not valid';
        }
        x = moment(x, format);
        if (x.isValid()) {
          return x;
        } else {
          throw 'Date not valid';
        }
      }
    };
  };

  datetime = date;

  integer = function(x) {
    var reg;
    if (x !== '') {
      reg = /^(\+|-)?\d+$/;
      if (!reg.test(x)) {
        throw "Must be an integer";
      } else {
        return parseInt(x);
      }
    } else {
      return '';
    }
  };

  float = function(x) {
    var reg;
    if (x !== '') {
      reg = /^(\+|-)?((\d+(\.\d+)?)|(\.\d+))$/;
      if (!reg.test(x)) {
        throw "Must be a float";
      } else {
        return parseFloat(x);
      }
    } else {
      return '';
    }
  };

  required = function(x) {
    if (x === '' || x === void 0 || x === null) {
      throw "It is required";
    }
  };

  min = function(limit) {
    return function(x) {
      if (x < limit) {
        throw "Value must be greater-equal than " + limit;
      }
    };
  };

  max = function(limit) {
    return function(x) {
      if (x > limit) {
        throw "Value must be less-equal than " + limit;
      }
    };
  };

  smin = function(limit) {
    return function(x) {
      if (x && x.length < limit) {
        throw "Length of string must be greater-equal than " + limit;
      }
    };
  };

  smax = function(limit) {
    return function(x) {
      if (x && x.length > limit) {
        throw "Length of string must be less-equal than " + limit;
      }
    };
  };

  references = function(list, attr) {
    return function(x) {
      var dct, obj;
      if (Meteor.isClient) {
        if (x === '') {
          return '';
        }
        dct = {};
        dct[attr] = x;
        obj = list.findOne(dct);
        if (obj) {
          return obj._id;
        } else {
          throw "Value must be in the list.";
        }
      } else {
        if (x === '') {
          return '';
        }
        if (list.findOne({
          _id: x
        })) {
          return x;
        } else {
          throw "Value must be a valid Id.";
        }
      }
    };
  };

  email = function(x) {
    var reg;
    if (x) {
      reg = /^([a-zA-Z0-9_.-])+@(([a-zA-Z0-9-])+.)+([a-zA-Z0-9]{2,4})+$/;
      if (!reg.test(x)) {
        throw "The field must be a valid email.";
      }
    }
  };

  string_select = function(list) {
    return function(x) {
      if (__indexOf.call(list, x) < 0) {
        throw "Value must be in the list";
      }
      return x;
    };
  };

  this.model2rform_validators = {
    boolean: boolean,
    string: string,
    text: text,
    nested: nested,
    nested_array: nested_array,
    string_array: string_array,
    date: date,
    datetime: datetime,
    integer: integer,
    float: float,
    required: required,
    min: min,
    max: max,
    smin: smin,
    smax: smax,
    references: references,
    email: email,
    string_select: string_select
  };

  if (typeof exports !== 'undefined') {
    exports.validators = this.model2rform_validators;
  }

}).call(this);
